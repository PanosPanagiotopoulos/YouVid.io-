

// File: C:\University\Fullstack_Dev\Fullstack_Projects\YouVid.io - Youtube Video Downloader App\Youtube_Video_Downloader_Backend\Services\VideoProcessingService.cs
```
﻿using Serilog;
using System.Diagnostics;
using System.Text.RegularExpressions;
using Xabe.FFmpeg;
using YoutubeExplode;
using YoutubeExplode.Videos;
using YoutubeExplode.Videos.Streams;
using YouVid.io___Youtube_Video_Downloader.Models;

namespace YouVid.io___Youtube_Video_Downloader.Services
{
    public class VideoProcessingService
    {
        private readonly YoutubeClient _youtubeClient;

        public VideoProcessingService()
        {
            _youtubeClient = new YoutubeClient();
        }

        public async Task<VideoResponse> Get(VideoDownloadSettings settings)
        {
            string inputFile = Path.Combine(Path.GetTempPath(), $"{Guid.NewGuid()}.mp4");
            File.Create(inputFile);
            string outputFile = Path.Combine(Path.GetTempPath(), $"{Guid.NewGuid()}.mp4");
            try
            {
                string videoId = GetYoutubeVideoIdFromUrl(settings.Url!);

                // Step 1: Get video info and best formats
                VideoInfo? videoInfo = await GetVideoInfoAsync(settings.Url!);

                // Step 2: Ensure the video info was retrieved successfully
                if (videoInfo == null || string.IsNullOrEmpty(videoInfo.Title))
                    throw new InvalidOperationException("Failed to retrieve video information.");

                string titleExtra = (settings.Settings == ProcessSettings.Normal) ? "-normal" : "-enhanced";
                VideoResponse response = new VideoResponse
                {
                    VideoStream = null,
                    VideoTitle = videoInfo.Title + titleExtra + ".mp4",
                    MimeType = "video/mp4"
                };

                // Step 3: Download the video using YoutubeExplode
                await DownloadVideoAsync(videoId, response.VideoStream);


                Log.Information("Processing video");
                // Step 3: Process video if required
                switch (settings.Settings)
                {
                    case ProcessSettings.Normal:
                        //await CompressVideoAsync(inputFile, outputFile);
                        break;

                    case ProcessSettings.High:
                        //await OptimizeVideoAsync(inputFile, outputFile);
                        break;

                    default:
                        throw new Exception("Invalid process setting given");
                }

                response.VideoStream.Position = 0;

                Log.Information("Finished processing.");

                return response;
            }
            finally
            {
                // Clean up temporary files, but not the outputStream.
                //DeleteFileIfExists(inputFile);
                //DeleteFileIfExists(outputFile);
            }
        }

        private async Task<VideoInfo?> GetVideoInfoAsync(string url)
        {
            try
            {
                Video video = await _youtubeClient.Videos.GetAsync(url);
                Log.Information("Video Info retrieved..");
                return new VideoInfo
                {
                    Title = video.Title,
                    Url = video.Url.ToString()
                };
            }
            catch (Exception ex)
            {
                Log.Error($"Error fetching video info: {ex.Message}");
                return null;
            }
        }

        private async Task DownloadVideoAsync(string videoId, Stream outputStream)
        {
            Log.Information("Downloading video and audio streams..");
            /*try
            {
                

                  StreamManifest streamManifest = await _youtubeClient.Videos.Streams.GetManifestAsync(videoId);

                  IVideoStreamInfo? bestVideoStream = streamManifest.GetVideoStreams()
                      .OrderByDescending(s => s.VideoQuality)
                      .ThenBy(s => s.Size)
                      .FirstOrDefault();

                  IAudioStreamInfo? bestAudioStream = streamManifest.GetAudioStreams()
                      .OrderByDescending(a => a.Bitrate)
                      .ThenBy(a => a.Size)
                      .FirstOrDefault();

                  if (bestVideoStream == null || bestAudioStream == null)
                  {
                      throw new InvalidOperationException("No suitable video or audio stream found.");
                  }

                  using (MemoryStream videoStream = new MemoryStream(), audioStream = new MemoryStream())
                  {
                      await Task.WhenAll(
                          _youtubeClient.Videos.Streams.CopyToAsync(bestVideoStream, videoStream).AsTask(),
                          _youtubeClient.Videos.Streams.CopyToAsync(bestAudioStream, audioStream).AsTask()
                      );

                      videoStream.Position = 0;
                      audioStream.Position = 0;

                      await CombineVideoAndAudio(videoStream, audioStream, outputStream);
                  }

                  Log.Information("Video and audio streams downloaded successfully.");
              }

              catch (Exception ex)
              {
                  Log.Error($"Error downloading video and audio streams: {ex.Message}");
                  throw;
              }*/

            StreamManifest streamManifest = await _youtubeClient.Videos.Streams.GetManifestAsync(videoId);
            IVideoStreamInfo? streamInfo = streamManifest.GetMuxedStreams().First();
            if (streamInfo == null)
            {
                throw new Exception("Muxed stream is empty");
            }

            outputStream = await _youtubeClient.Videos.Streams.GetAsync(streamInfo!);
        }


        public async Task CombineVideoAndAudio(Stream videoStream, Stream audioStream, Stream outputStream)
        {
            // Create temporary files for input streams
            string videoFilePath = Path.GetTempFileName() + ".mp4";
            string audioFilePath = Path.GetTempFileName() + ".mp4";
            string outputFilePath = Path.GetTempFileName() + ".mp4";

            try
            {
                // Write streams to temporary files
                using (FileStream videoFile = File.Create(videoFilePath), audioFile = File.Create(audioFilePath))
                {
                    Task videoCopy = videoStream.CopyToAsync(videoFile);
                    Task audioCopy = audioStream.CopyToAsync(audioFile);

                    await Task.WhenAll(videoCopy, audioCopy);
                }

                // Extract media info
                Task<IMediaInfo> videoInfoTask = FFmpeg.GetMediaInfo(videoFilePath);
                Task<IMediaInfo> audioInfoTask = FFmpeg.GetMediaInfo(audioFilePath);

                await Task.WhenAll(videoInfoTask, audioInfoTask);

                IMediaInfo videoInfo = videoInfoTask.Result;
                IMediaInfo audioInfo = audioInfoTask.Result;

                // Extract video and audio streams
                IVideoStream? videoStreamInfo = videoInfo.VideoStreams.FirstOrDefault();
                IAudioStream? audioStreamInfo = audioInfo.AudioStreams.FirstOrDefault();

                if (videoStreamInfo == null)
                    throw new Exception("No video stream found in the provided video file.");

                if (audioStreamInfo == null)
                    throw new Exception("No audio stream found in the provided audio file.");

                // Combine video and audio
                IConversion conversion = FFmpeg.Conversions.New()
                    .AddStream(videoStreamInfo)
                    .AddStream(audioStreamInfo)
                    .SetOutput(outputFilePath);

                await conversion.Start();

                // Write the combined file to the output stream
                using var outputFile = File.OpenRead(outputFilePath);
                await outputFile.CopyToAsync(outputStream);
            }

            finally
            {
                // Cleanup temporary files
                DeleteFileIfExists(videoFilePath);
                DeleteFileIfExists(audioFilePath);
                DeleteFileIfExists(outputFilePath);
            }
        }


        public async Task CompressVideoAsync(string inputFilePath, string outputFilePath)
        {
            try
            {
                // Compress without hindering quality
                string ffmpegArguments = $"-i \"{inputFilePath}\" -vcodec libx264 -crf 0 -preset slow \"{outputFilePath}\"";

                await RunFFmpegAsync(ffmpegArguments);

                Console.WriteLine($"Video compressed successfully: {outputFilePath}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"An error occurred during compression: {ex.Message}");
            }
        }

        public async Task OptimizeVideoAsync(string inputFilePath, string outputFilePath)
        {
            try
            {
                // Enhance quality and optimize for speed without hindering quality
                string ffmpegArguments = $"-i \"{inputFilePath}\" -vcodec libx264 -crf 28 -preset veryfast -vf scale=-1:1080 -tune film \"{outputFilePath}\"";

                await RunFFmpegAsync(ffmpegArguments);

                Console.WriteLine($"Video optimized successfully: {outputFilePath}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"An error occurred during optimization: {ex.Message}");
            }
        }

        private async Task RunFFmpegAsync(string arguments)
        {
            Process process = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = "ffmpeg",
                    Arguments = arguments,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    UseShellExecute = false,
                    CreateNoWindow = true
                }
            };

            process.Start();

            await Task.Run(() => process.WaitForExit());

            if (process.ExitCode != 0)
            {
                throw new Exception(await process.StandardError.ReadToEndAsync());
            }
        }

        private async Task CopyToStreamAsync(string tempFilePath, Stream outputStream)
        {
            try
            {
                using (var fileStream = new FileStream(tempFilePath, FileMode.Open, FileAccess.Read, FileShare.Read))
                {
                    await fileStream.CopyToAsync(outputStream);
                    await outputStream.FlushAsync();
                }

                Console.WriteLine("File copied to stream successfully.");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"An error occurred while copying to stream: {ex.Message}");
            }
        }

        public string GetYoutubeVideoIdFromUrl(string url)
        {
            Regex regex = new Regex(@"(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|\S*?[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})");
            Match match = regex.Match(url);
            if (!match.Success)
                throw new FormatException("Invalid YouTube URL.");
            return match.Groups[1].Value;
        }

        private void DeleteFileIfExists(string filePath)
        {
            try
            {
                if (File.Exists(filePath))
                {
                    File.Delete(filePath);
                    Log.Information($"Deleted temporary file: {filePath}");
                }
            }
            catch (Exception ex)
            {
                Log.Error($"Failed to delete temporary file {filePath}: {ex.Message}");
            }
        }

        public class VideoInfo
        {
            public string? Title { get; set; }
            public string? Url { get; set; }
        }
    }
}
```


// File: C:\University\Fullstack_Dev\Fullstack_Projects\YouVid.io - Youtube Video Downloader App\Youtube_Video_Downloader_Backend\Services\YoutubeService.cs
```
﻿using System.Text.RegularExpressions;
using YoutubeExplode;
using YouVid.io___Youtube_Video_Downloader.Models;

namespace YouVid.io___Youtube_Video_Downloader.Services
{
    public class YoutubeService
    {
        private readonly YoutubeClient _youtubeClient;

        public YoutubeService()
        {
            _youtubeClient = new YoutubeClient();
        }

        public async Task<Stream> DownloadVideoAsStreamAsync(
            VideoDownloadSettings settings,
            VideoDownloadPreference preference,
            CancellationToken cancellationToken = default)
        {
            if (string.IsNullOrWhiteSpace(settings.Url))
                throw new ArgumentException("Video URL cannot be null or empty.", nameof(settings.Url));

            try
            {
                // Parse the video ID from the URL
                string videoId = GetYoutubeVideoIdFromUrl(settings.Url);

                // Retrieve the stream manifest
                YoutubeExplode.Videos.Streams.StreamManifest streamManifest = await _youtubeClient.Videos.Streams.GetManifestAsync(videoId, cancellationToken);
                // Select the best download option based on preference
                IReadOnlyList<VideoDownloadOption> downloadOptions = VideoDownloadOption.ResolveAll(streamManifest);
                VideoDownloadOption bestOption = preference.TryGetBestOption(downloadOptions)
                    ?? throw new InvalidOperationException("No suitable download option found.");

                // Create a temporary memory stream for the video
                MemoryStream memoryStream = new MemoryStream();
                foreach (var streamInfo in bestOption.StreamInfos)
                {
                    await _youtubeClient.Videos.Streams.CopyToAsync(streamInfo, memoryStream, cancellationToken: cancellationToken);
                }

                memoryStream.Position = 0; // Reset the stream position for reading
                return memoryStream;
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException($"Failed to download video: {ex.Message}", ex);
            }
        }

        private string GetYoutubeVideoIdFromUrl(string url)
        {
            Regex regex = new Regex(@"(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|\S*?[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})");
            Match match = regex.Match(url);
            if (!match.Success)
                throw new FormatException("Invalid YouTube URL.");
            return match.Groups[1].Value;
        }
    }
}
```


// File: C:\University\Fullstack_Dev\Fullstack_Projects\YouVid.io - Youtube Video Downloader App\Youtube_Video_Downloader_Backend\Models\FFmpeg.cs
```
﻿namespace YouVid.io___Youtube_Video_Downloader.Models
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;

    public static class MFFmpeg
    {
        private static string CliFileName { get; } =
            OperatingSystem.IsWindows() ? "ffmpeg.exe" : "ffmpeg";

        public static string? TryGetCliFilePath()
        {
            static IEnumerable<string> GetProbeDirectoryPaths()
            {
                yield return AppContext.BaseDirectory;
                yield return Directory.GetCurrentDirectory();

                // Process PATH
                if (
                    Environment.GetEnvironmentVariable("PATH")?.Split(Path.PathSeparator) is
                    { } processPaths
                )
                {
                    foreach (var path in processPaths)
                        yield return path;
                }

                // Registry-based PATH variables
                if (OperatingSystem.IsWindows())
                {
                    // User PATH
                    if (
                        Environment
                            .GetEnvironmentVariable("PATH", EnvironmentVariableTarget.User)
                            ?.Split(Path.PathSeparator) is
                        { } userPaths
                    )
                    {
                        foreach (var path in userPaths)
                            yield return path;
                    }

                    // System PATH
                    if (
                        Environment
                            .GetEnvironmentVariable("PATH", EnvironmentVariableTarget.Machine)
                            ?.Split(Path.PathSeparator) is
                        { } systemPaths
                    )
                    {
                        foreach (var path in systemPaths)
                            yield return path;
                    }
                }
            }

            return GetProbeDirectoryPaths()
                .Distinct(StringComparer.Ordinal)
                .Select(dirPath => Path.Combine(dirPath, CliFileName))
                .FirstOrDefault(File.Exists);
        }

        public static bool IsBundled() =>
            File.Exists(Path.Combine(AppContext.BaseDirectory, CliFileName));

        public static bool IsAvailable() => !string.IsNullOrWhiteSpace(TryGetCliFilePath());
    }
}

```


// File: C:\University\Fullstack_Dev\Fullstack_Projects\YouVid.io - Youtube Video Downloader App\Youtube_Video_Downloader_Backend\Models\FileNameTemplate.cs
```
﻿namespace YouVid.io___Youtube_Video_Downloader.Models
{
    using System;
    using YoutubeExplode.Videos;
    using YoutubeExplode.Videos.Streams;

    public static class FileNameTemplate
    {
        public static string Apply(
            string template,
            IVideo video,
            Container container,
            string? number = null
        ) =>
            PathEx.EscapeFileName(
                template
                    .Replace("$numc", number ?? "", StringComparison.Ordinal)
                    .Replace("$num", number is not null ? $"[{number}]" : "", StringComparison.Ordinal)
                    .Replace("$id", video.Id, StringComparison.Ordinal)
                    .Replace("$title", video.Title, StringComparison.Ordinal)
                    .Replace("$author", video.Author.ChannelTitle, StringComparison.Ordinal)
                    .Replace(
                        "$uploadDate",
                        (video as Video)?.UploadDate.ToString("yyyy-MM-dd") ?? "",
                        StringComparison.Ordinal
                    )
                    .Trim()
                    + '.'
                    + container.Name
            );
    }
}

```


// File: C:\University\Fullstack_Dev\Fullstack_Projects\YouVid.io - Youtube Video Downloader App\Youtube_Video_Downloader_Backend\Models\PathEx.cs
```
﻿namespace YouVid.io___Youtube_Video_Downloader.Models
{
    using System.Collections.Generic;
    using System.IO;
    using System.Text;

    public static class PathEx
    {
        private static readonly HashSet<char> InvalidFileNameChars =
        [
            .. Path.GetInvalidFileNameChars(),
    ];

        public static string EscapeFileName(string path)
        {
            var buffer = new StringBuilder(path.Length);

            foreach (var c in path)
                buffer.Append(!InvalidFileNameChars.Contains(c) ? c : '_');

            return buffer.ToString();
        }
    }
}

```


// File: C:\University\Fullstack_Dev\Fullstack_Projects\YouVid.io - Youtube Video Downloader App\Youtube_Video_Downloader_Backend\Models\ProcessSettings.cs
```
﻿namespace YouVid.io___Youtube_Video_Downloader.Models
{
    public enum ProcessSettings
    {
        Normal = 1,
        High = 2,
    }
}

```


// File: C:\University\Fullstack_Dev\Fullstack_Projects\YouVid.io - Youtube Video Downloader App\Youtube_Video_Downloader_Backend\Models\VideoDownloader.cs
```
﻿namespace YouVid.io___Youtube_Video_Downloader.Models
{
    using Gress;
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Net;
    using System.Threading;
    using System.Threading.Tasks;
    using YoutubeExplode;
    using YoutubeExplode.Converter;
    using YoutubeExplode.Videos;
    using YoutubeExplode.Videos.ClosedCaptions;
    using ConversionPreset = YoutubeExplode.Converter.ConversionPreset;

    public class VideoDownloader(IReadOnlyList<Cookie>? initialCookies = null)
    {
        private readonly YoutubeClient _youtube = new(initialCookies ?? []);

        public async Task<IReadOnlyList<VideoDownloadOption>> GetDownloadOptionsAsync(
            VideoId videoId,
            bool includeLanguageSpecificAudioStreams = true,
            CancellationToken cancellationToken = default
        )
        {
            var manifest = await _youtube.Videos.Streams.GetManifestAsync(videoId, cancellationToken);
            return VideoDownloadOption.ResolveAll(manifest, includeLanguageSpecificAudioStreams);
        }

        public async Task<VideoDownloadOption> GetBestDownloadOptionAsync(
            VideoId videoId,
            VideoDownloadPreference preference,
            bool includeLanguageSpecificAudioStreams = true,
            CancellationToken cancellationToken = default
        )
        {
            var options = await GetDownloadOptionsAsync(
                videoId,
                includeLanguageSpecificAudioStreams,
                cancellationToken
            );

            return preference.TryGetBestOption(options)
                ?? throw new InvalidOperationException("No suitable download option found.");
        }

        public async Task DownloadVideoAsync(
            string filePath,
            IVideo video,
            VideoDownloadOption downloadOption,
            bool includeSubtitles = false,
            IProgress<Percentage>? progress = null,
            CancellationToken cancellationToken = default
        )
        {
            // Include subtitles in the output container
            var trackInfos = new List<ClosedCaptionTrackInfo>();
            if (includeSubtitles && !downloadOption.Container.IsAudioOnly)
            {
                var manifest = await _youtube.Videos.ClosedCaptions.GetManifestAsync(
                    video.Id,
                    cancellationToken
                );

                trackInfos.AddRange(manifest.Tracks);
            }

            var dirPath = Path.GetDirectoryName(filePath);
            if (!string.IsNullOrWhiteSpace(dirPath))
                Directory.CreateDirectory(dirPath);

            await _youtube.Videos.DownloadAsync(
                downloadOption.StreamInfos,
                trackInfos,
                new ConversionRequestBuilder(filePath)
                    .SetFFmpegPath(MFFmpeg.TryGetCliFilePath() ?? "ffmpeg")
                    .SetContainer("mp4")
                    .SetPreset(ConversionPreset.Medium)
                    .Build(),
                progress?.ToDoubleBased(),
                cancellationToken
            );
        }
    }
}

```


// File: C:\University\Fullstack_Dev\Fullstack_Projects\YouVid.io - Youtube Video Downloader App\Youtube_Video_Downloader_Backend\Models\VideoDownloadOption.cs
```
﻿namespace YouVid.io___Youtube_Video_Downloader.Models
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using YoutubeExplode.Videos.Streams;

    public partial record VideoDownloadOption(
        Container Container,
        bool IsAudioOnly,
        IReadOnlyList<IStreamInfo> StreamInfos
    )
    {
        public VideoQuality? VideoQuality { get; } =
            StreamInfos.OfType<IVideoStreamInfo>().MaxBy(s => s.VideoQuality)?.VideoQuality;
    }

    public partial record VideoDownloadOption
    {
        internal static IReadOnlyList<VideoDownloadOption> ResolveAll(
            StreamManifest manifest,
            bool includeLanguageSpecificAudioStreams = true
        )
        {
            IEnumerable<VideoDownloadOption> GetVideoAndAudioOptions()
            {
                var videoStreamInfos = manifest
                    .GetVideoStreams()
                    .OrderByDescending(v => v.VideoQuality);

                foreach (var videoStreamInfo in videoStreamInfos)
                {
                    // Muxed stream
                    if (videoStreamInfo is MuxedStreamInfo)
                    {
                        yield return new VideoDownloadOption(
                            videoStreamInfo.Container,
                            false,
                            [videoStreamInfo]
                        );
                    }
                    // Separate audio + video stream
                    else
                    {
                        var audioStreamInfos = manifest
                            .GetAudioStreams()
                            // Prefer audio streams with the same container
                            .OrderByDescending(s => s.Container == videoStreamInfo.Container)
                            .ThenByDescending(s => s is AudioOnlyStreamInfo)
                            .ThenByDescending(s => s.Bitrate)
                            .ToArray();

                        // Prefer language-specific audio streams, if available and if allowed
                        var languageSpecificAudioStreamInfos = includeLanguageSpecificAudioStreams
                            ? audioStreamInfos
                                .Where(s => s.AudioLanguage is not null)
                                .DistinctBy(s => s.AudioLanguage)
                                // Default language first so it's encoded as the first audio track in the output file
                                .OrderByDescending(s => s.IsAudioLanguageDefault)
                                .ToArray()
                            : [];

                        // If there are language-specific streams, include them all
                        if (languageSpecificAudioStreamInfos.Any())
                        {
                            yield return new VideoDownloadOption(
                                videoStreamInfo.Container,
                                false,
                                [videoStreamInfo, .. languageSpecificAudioStreamInfos]
                            );
                        }
                        // If there are no language-specific streams, download the single best quality audio stream
                        else
                        {
                            var audioStreamInfo = audioStreamInfos
                                // Prefer audio streams in the default language (or non-language-specific streams)
                                .OrderByDescending(s => s.IsAudioLanguageDefault ?? true)
                                .FirstOrDefault();

                            if (audioStreamInfo is not null)
                            {
                                yield return new VideoDownloadOption(
                                    videoStreamInfo.Container,
                                    false,
                                    [videoStreamInfo, audioStreamInfo]
                                );
                            }
                        }
                    }
                }
            }

            IEnumerable<VideoDownloadOption> GetAudioOnlyOptions()
            {
                // WebM-based audio-only containers
                {
                    var audioStreamInfo = manifest
                        .GetAudioStreams()
                        // Prefer audio streams in the default language (or non-language-specific streams)
                        .OrderByDescending(s => s.IsAudioLanguageDefault ?? true)
                        // Prefer audio streams with the same container
                        .ThenByDescending(s => s.Container == Container.WebM)
                        .ThenByDescending(s => s is AudioOnlyStreamInfo)
                        .ThenByDescending(s => s.Bitrate)
                        .FirstOrDefault();

                    if (audioStreamInfo is not null)
                    {
                        yield return new VideoDownloadOption(Container.WebM, true, [audioStreamInfo]);

                        yield return new VideoDownloadOption(Container.Mp3, true, [audioStreamInfo]);

                        yield return new VideoDownloadOption(
                            new Container("ogg"),
                            true,
                            [audioStreamInfo]
                        );
                    }
                }

                // Mp4-based audio-only containers
                {
                    var audioStreamInfo = manifest
                        .GetAudioStreams()
                        // Prefer audio streams in the default language (or non-language-specific streams)
                        .OrderByDescending(s => s.IsAudioLanguageDefault ?? true)
                        // Prefer audio streams with the same container
                        .ThenByDescending(s => s.Container == Container.Mp4)
                        .ThenByDescending(s => s is AudioOnlyStreamInfo)
                        .ThenByDescending(s => s.Bitrate)
                        .FirstOrDefault();

                    if (audioStreamInfo is not null)
                    {
                        yield return new VideoDownloadOption(Container.Mp4, true, [audioStreamInfo]);
                    }
                }
            }

            // Deduplicate download options by video quality and container
            EqualityComparer<VideoDownloadOption> comparer = EqualityComparer<VideoDownloadOption>.Create(
                (x, y) => x?.VideoQuality == y?.VideoQuality && x?.Container == y?.Container,
                x => HashCode.Combine(x.VideoQuality, x.Container)
            );

            HashSet<VideoDownloadOption> options = new HashSet<VideoDownloadOption>(comparer);

            IEnumerable<VideoDownloadOption> videoOptions = GetVideoAndAudioOptions();
            IEnumerable<VideoDownloadOption> audioOptions = GetAudioOnlyOptions();

            foreach (VideoDownloadOption option in videoOptions)
                options.Add(option);

            foreach (VideoDownloadOption option in audioOptions)
                options.Add(option);

            return options.ToArray();
        }
    }
}

```


// File: C:\University\Fullstack_Dev\Fullstack_Projects\YouVid.io - Youtube Video Downloader App\Youtube_Video_Downloader_Backend\Models\VideoDownloadPreference.cs
```
﻿using YoutubeExplode.Videos.Streams;

namespace YouVid.io___Youtube_Video_Downloader.Models
{

    public record VideoDownloadPreference(
    Container PreferredContainer,
    VideoQualityPreference PreferredVideoQuality
)
    {
        public VideoDownloadOption? TryGetBestOption(IReadOnlyList<VideoDownloadOption> options)
        {
            // Short-circuit for audio-only formats
            if (PreferredContainer.IsAudioOnly)
                return options.FirstOrDefault(o => o.Container == PreferredContainer);

            var orderedOptions = options.OrderBy(o => o.VideoQuality).ToArray();

            var preferredOption = PreferredVideoQuality switch
            {
                VideoQualityPreference.Highest => orderedOptions.LastOrDefault(o =>
                    o.Container == PreferredContainer
                ),

                VideoQualityPreference.UpTo1080p => orderedOptions
                    .Where(o => o.VideoQuality?.MaxHeight <= 1080)
                    .LastOrDefault(o => o.Container == PreferredContainer),

                VideoQualityPreference.UpTo720p => orderedOptions
                    .Where(o => o.VideoQuality?.MaxHeight <= 720)
                    .LastOrDefault(o => o.Container == PreferredContainer),

                VideoQualityPreference.UpTo480p => orderedOptions
                    .Where(o => o.VideoQuality?.MaxHeight <= 480)
                    .LastOrDefault(o => o.Container == PreferredContainer),

                VideoQualityPreference.UpTo360p => orderedOptions
                    .Where(o => o.VideoQuality?.MaxHeight <= 360)
                    .LastOrDefault(o => o.Container == PreferredContainer),

                VideoQualityPreference.Lowest => orderedOptions.LastOrDefault(o =>
                    o.Container == PreferredContainer
                ),

                _ => throw new InvalidOperationException(
                    $"Unknown video quality preference '{PreferredVideoQuality}'."
                ),
            };

            return preferredOption
                ?? orderedOptions.FirstOrDefault(o => o.Container == PreferredContainer);
        }
    }
}
```


// File: C:\University\Fullstack_Dev\Fullstack_Projects\YouVid.io - Youtube Video Downloader App\Youtube_Video_Downloader_Backend\Models\VideoDownloadSettings.cs
```
﻿namespace YouVid.io___Youtube_Video_Downloader.Models
{
    public class VideoDownloadSettings
    {
        public string? Url { get; set; }
        public string? VideoId { get; set; }

        public ProcessSettings Settings { get; set; }
    }
}

```


// File: C:\University\Fullstack_Dev\Fullstack_Projects\YouVid.io - Youtube Video Downloader App\Youtube_Video_Downloader_Backend\Models\VideoQualityPreference.cs
```
﻿namespace YouVid.io___Youtube_Video_Downloader.Models
{
    using System;

    public enum VideoQualityPreference
    {
        // ReSharper disable InconsistentNaming
        Lowest,
        UpTo360p,
        UpTo480p,
        UpTo720p,
        UpTo1080p,
        Highest,
        // ReSharper restore InconsistentNaming
    }

    public static class VideoQualityPreferenceExtensions
    {
        public static string GetDisplayName(this VideoQualityPreference preference) =>
            preference switch
            {
                VideoQualityPreference.Lowest => "Lowest quality",
                VideoQualityPreference.UpTo360p => "≤ 360p",
                VideoQualityPreference.UpTo480p => "≤ 480p",
                VideoQualityPreference.UpTo720p => "≤ 720p",
                VideoQualityPreference.UpTo1080p => "≤ 1080p",
                VideoQualityPreference.Highest => "Highest quality",
                _ => throw new ArgumentOutOfRangeException(nameof(preference)),
            };
    }
}

```


// File: C:\University\Fullstack_Dev\Fullstack_Projects\YouVid.io - Youtube Video Downloader App\Youtube_Video_Downloader_Backend\Models\VideoResponse.cs
```
﻿namespace YouVid.io___Youtube_Video_Downloader.Models
{
    public class VideoResponse
    {
        public Stream? VideoStream { get; set; }
        public string? VideoTitle { get; set; }
        public string? MimeType { get; set; }


    }
}

```


// File: C:\University\Fullstack_Dev\Fullstack_Projects\YouVid.io - Youtube Video Downloader App\Youtube_Video_Downloader_Backend\Controllers\VideoProcessController.cs
```
﻿using Microsoft.AspNetCore.Mvc;
using Serilog;
using YoutubeExplode.Videos.Streams;
using YouVid.io___Youtube_Video_Downloader.Models;
using YouVid.io___Youtube_Video_Downloader.Services;

namespace YouVid.io___Youtube_Video_Downloader.Controllers
{
    [ApiController]
    [Route("api/video")]
    public class VideoProcessController : ControllerBase
    {
        private readonly VideoProcessingService _youtubeService;
        private readonly YoutubeService youtubeService;

        public VideoProcessController(VideoProcessingService youtubeService, YoutubeService youtubeService2)
        {
            _youtubeService = youtubeService;
            this.youtubeService = youtubeService2;
        }

        [HttpGet("download")]
        public async Task<IActionResult> DownloadVideo([FromQuery] VideoDownloadSettings videoDownloadSettings)
        {
            if (!ModelState.IsValid)
            {
                Log.Error("Faulty Model State Data");
                return BadRequest(ModelState);
            }

            if (string.IsNullOrEmpty(videoDownloadSettings.Url) || string.IsNullOrWhiteSpace(videoDownloadSettings.Url.Trim()))
            {
                Log.Error("Not Valid URL sent to download");
                ModelState.AddModelError("error", "Not Valid URL sent to download");
                return BadRequest(ModelState);
            }

            if (videoDownloadSettings.Settings == default(ProcessSettings))
            {
                Log.Error("Not Process settings to process");
                ModelState.AddModelError("error", "Not Valid Process Setting sent to process");
                return BadRequest(ModelState);
            }

            try
            {
                // Create a VideoDownloadPreference object
                var preferredContainer = Container.Mp4; // Choose MP4 as the preferred container
                var preferredQuality = VideoQualityPreference.UpTo1080p; // Choose up to 1080p quality

                var videoDownloadPreference = new VideoDownloadPreference(preferredContainer, preferredQuality);
                // Process and retrieve video response
                //VideoResponse result = await _youtubeService.Get(videoDownloadSettings);
                VideoResponse result = new VideoResponse
                {
                    VideoStream = await youtubeService.DownloadVideoAsStreamAsync
                    (
                        videoDownloadSettings,
                        videoDownloadPreference
                    ),
                    VideoTitle = "Test Video.mp4",
                    MimeType = "video/mp4"
                };

                Log.Information($"Serving video: {result.VideoTitle}");


                // Set the Content-Disposition header to indicate the file name in the browser
                //if (HttpContext.Response.Headers.ContainsKey("Content-Disposition"))
                //{
                //    HttpContext.Response.Headers["Content-Disposition"] = $"attachment; filename=\"{result.VideoTitle}\"";
                //}

                //else { Response.Headers.Append("Content-Disposition", $"attachment; filename=\"{result.VideoTitle}\""); }


                return File(result.VideoStream, result.MimeType, result.VideoTitle, enableRangeProcessing: true);
            }

            catch (InvalidOperationException ioe)
            {
                Log.Error(ioe, $"An 404 error occurred while processing the video: {ioe.Message}");
                ModelState.AddModelError("error", ioe.Message);
                return NotFound(ModelState);
            }
            catch (IOException ioex)
            {
                Log.Error(ioex, $"An IO error occurred while downloading the video: {ioex.Message}");
                // Do not return BadRequest for IO exceptions, just log the error
                return StatusCode(500, "An error occurred while processing the video.");
            }
            catch (Exception ex)
            {
                Log.Error(ex, $"An 400 or 500 error occurred while downloading the video: {ex.Message}");
                ModelState.AddModelError("error", ex.Message);
                return BadRequest(ModelState);
            }
        }
    }
}

```
